require 'msf/core'

class MetasploitModule < Msf::Auxiliary
    
    include Msf::Auxiliary::Scanner
    include Msf::Exploit::Remote::Tcp
  
    def initialize(info = {})
        super(update_info(info,
           'Name'  => 'Fuzzer SMTP',
           'Description'   => 'Módulo auxiliar para tratar de obtener nombres de usuario válidos en un servidor SMTP utilizando un diccionario',
           'Author'    => [ 'Mikel Aguirre' ],
           'License'   => MSF_LICENSE
        ))

        register_options(
            [
                Opt::RPORT(25),
                OptString.new('initRange',[true,"Valor de inicio de Rango"]),
                OptString.new('maxRange',[true,"Valor de finalización de Rango"]),
                OptString.new('ipSegAddress',[true,"Subred X.X.X"]),
		# Definimos una opcion que sólo acepta tres valores
                OptEnum.new('smtpMethod',[true,"Método de consulta:",'VRFY',
		[
		  'VRFY',
		  'EXPN',
		  'RCPT TO'
		],'VRFY']),
                OptString.new('usersFile',[true,"Fichero diccionario"]),
                OptString.new('outputFilename',[true,"Fichero salida"]),
            ], self.class)
	# EXPN consulta existencia mailing list
        deregister_options('RHOSTS','RHOST')
    end
  
    def run
        validUsers=''
        min = datastore['initRange'].to_i
        max = datastore['maxRange'].to_i
        # Iteramos desde el valor init hasta el max
        (min..max).each do |rango|
        # Construimos la IP con el valor de subred más el indice (rango) del bucle
            ip = datastore['ipSegAddress']+'.'+rango.to_s
            print_status("Conectando con la IP: #{ip}")
            begin
                connect(true, {'RHOST'=>ip, 'RPORT'=>datastore['RPORT']})
                # Recogemos la respuesta del servidor. Si es nula, almacenamos ''
                banner = sock.get_once || ''
                print_status("Conectado a: #{banner}")
                # Si el servidor SMTP responde con un OK abrimos el fichero diccionario
                if banner.include? "220"
                    File.open(datastore['usersFile'], "r") do |file|
                        # Si el método es VRFY o EXPN
                        if (datastore['smtpMethod'] == 'VRFY' || datastore['smtpMethod'] == 'EXPN')
                        # Por cada registro del diccionario lanzamos una petición al servidor utilizando dicho método 
                        # pasandole el nombre de usuario
                            file.each do |user|
                                sock.put(datastore['smtpMethod']+' '+user)
				                # Recogemos la respuesta del servidor. Si es nula, almacenamos ''
                                result=sock.get_once || ''
                                # Si la respuesta contiene un OK, guardamos un registro e imprimimos en pantalla
                                if result.include? "252"
                                    validUsers += "#{ip}: #{result}\n"
                                    usuario = user.chomp # Eliminamos el salto de línea de user
                                    print_good("Usuario #{usuario} encontrado!. Respuesta del servidor #{ip}: #{result}")
                                else
                                    print_status("Respuesta del servidor #{ip}: #{result}")
                                end
                            end
                        else
                        # El método RCPT TO necesita que primero indiquemos un remitente
                        file.each do |user|		
                        # Lanzamos el comando MAIL FROM y recogemos la respuesta	    
                            sock.put("MAIL FROM: fake@fsociety.net\n")
                            result=sock.get_once || ''
				            # Si la respuesta contiene un OK, lanzamos el comando RCPT TO con el nombre de usuario
                            if result.include? "250"
                                sock.put(datastore['smtpMethod']+": "+user)
                                result=sock.get_once || ''
                                # Si la respuesta contiene un OK, guardamos un registro e imprimimos en pantalla 
                                if result.include? "250"
                                    usuario = user.chomp
                                    validUsers += "#{ip}: #{usuario} #{result}\n"
                                    print_good("Usuario #{usuario} encontrado!. Respuesta del servidor #{ip}: #{result}")
                                else
                                    print_status("Respuesta del servidor #{ip}: #{result}")
                                end
                            else
				            # El servidor no nos acepta el MAIL FROM
                                print_status("Respuesta del servidor #{ip}: #{result}")
                            end
                            # Enviamos al servidor SMTP el comando RSET para cancelar la tarea y recogemos la respuesta
			    	        sock.put("RSET\n")
			    	        result=sock.get_once
                        end
                    end
                    # Cerramos el fichero diccionario
                    file.close
                end
            end
            # Controlamos las excepciones e imprimimos por pantalla el error
            rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e
                print_error("Error: #{e.message}\n")
            ensure
                disconnect
            end
        end
        #Si hemos recogido algún positivo, escribimos en el fichero salida
        if validUsers != ''
        	File.open(datastore['outputFilename'], "w") do |filew|
            	filew.write(validUsers)
            	filew.close
        	end
        end
    end
end
